{"version":3,"sources":["webpack:///webpack/bootstrap 6efeac7a6493e3609222","webpack:///./src/Page.js","webpack:///./src/AStar.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AC7DA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C,6BAA6B,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sCAAsC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD,gCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA,oCAAoC,oCAAoC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;AC9KA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC","file":"./build/out.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6efeac7a6493e3609222","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst AStar_1 = require(\"./AStar\");\r\nvar screenMap;\r\ndocument.addEventListener(\"DOMContentLoaded\", GeneratePage);\r\nfunction GeneratePage() {\r\n    const generateButton = document.getElementById(\"generate\");\r\n    const runButton = document.getElementById(\"run\");\r\n    const mouseGridElement = document.getElementById(\"mousegrid\");\r\n    const gridElement = document.getElementById(\"grid\");\r\n    const hideStats = document.getElementById(\"hideStats\");\r\n    mouseGridElement.addEventListener(\"mousedown\", MouseDownOnGridEvent);\r\n    mouseGridElement.addEventListener(\"mousemove\", MouseDownOnGridEvent);\r\n    function MouseDownOnGridEvent(event) {\r\n        if (event.buttons & 1 && screenMap !== undefined) {\r\n            const row = Math.floor((event.offsetX / this.clientWidth) * screenMap.width);\r\n            const column = Math.floor((event.offsetY / this.clientHeight) * screenMap.height);\r\n            SetGrid(screenMap, row, column);\r\n            UpdateGrid(gridElement);\r\n            //document.getElementById(\"gridx\").textContent = ((event.offsetX / this.clientWidth) * screenMap.width).toString();\r\n            //document.getElementById(\"gridy\").textContent = ((event.offsetY / this.clientHeight) * screenMap.height).toString();\r\n        }\r\n        //document.getElementById(\"mousex\").textContent = event.offsetX.toString();\r\n        //document.getElementById(\"mousey\").textContent = event.offsetY.toString();\r\n        //document.getElementById(\"clientw\").textContent = this.clientWidth.toString();\r\n        //document.getElementById(\"clienth\").textContent = this.clientHeight.toString();\r\n    }\r\n    function SetGrid(map, row, column) {\r\n        const spaceTypes = document.getElementsByName(\"spaceType\").values();\r\n        let selectedButton;\r\n        for (const spaceType of spaceTypes)\r\n            if (spaceType.checked)\r\n                selectedButton = spaceType;\r\n        if (selectedButton.value === \"open\") {\r\n            map.grid[row][column] = 0;\r\n        }\r\n        else if (selectedButton.value === \"blocked\") {\r\n            map.grid[row][column] = 1;\r\n        }\r\n        else if (selectedButton.value === \"start\") {\r\n            if (map.start)\r\n                map.grid[map.start.x][map.start.y] = 0;\r\n            map.start = new AStar_1.GridPosition(row, column);\r\n            map.grid[row][column] = 0;\r\n        }\r\n        else if (selectedButton.value === \"goal\") {\r\n            if (map.goal)\r\n                map.grid[map.goal.x][map.goal.y] = 0;\r\n            map.goal = new AStar_1.GridPosition(row, column);\r\n            map.grid[row][column] = 0;\r\n        }\r\n    }\r\n    function UpdateGrid(element) {\r\n        const children = Array.from(element.children);\r\n        for (const child of children) {\r\n            const x = +child.getAttribute(\"x\");\r\n            const y = +child.getAttribute(\"y\");\r\n            if (screenMap.start && screenMap.start.x === x && screenMap.start.y === y) {\r\n                child.className = \"gridSpace start\";\r\n            }\r\n            else if (screenMap.goal && screenMap.goal.x === x && screenMap.goal.y === y) {\r\n                child.className = \"gridSpace goal\";\r\n            }\r\n            else if (screenMap.grid[x][y] === 0) {\r\n                child.className = \"gridSpace open\";\r\n            }\r\n            else if (screenMap.grid[x][y] === 1) {\r\n                child.className = \"gridSpace blocked\";\r\n            }\r\n            else if (screenMap.grid[x][y] === 2) {\r\n                child.className = \"gridSpace path\";\r\n            }\r\n            if (screenMap.results) {\r\n                const result = screenMap.results.history[x][y];\r\n                child.children.item(0).textContent = result.pos.toString();\r\n                child.children.item(1).textContent = \"g: \" + Math.round(result.g * 100) / 100;\r\n                child.children.item(2).textContent = \"h: \" + Math.round(result.h * 100) / 100;\r\n                child.children.item(3).textContent = \"f: \" + Math.round(result.f * 100) / 100;\r\n            }\r\n        }\r\n    }\r\n    generateButton.addEventListener(\"click\", GenerateGridEvent);\r\n    function getNumber(el) {\r\n        return +el.value === NaN ? 1 : +el.value;\r\n    }\r\n    function GenerateGridEvent() {\r\n        const map = {\r\n            grid: undefined,\r\n            width: getNumber(document.getElementById(\"width\")),\r\n            height: getNumber(document.getElementById(\"height\")),\r\n            start: undefined,\r\n            goal: undefined,\r\n            results: undefined\r\n        };\r\n        const grid = [];\r\n        for (let row = 0; row < map.width; row++) {\r\n            grid.push([]);\r\n            for (let column = 0; column < map.height; column++) {\r\n                grid[row].push(0);\r\n            }\r\n        }\r\n        screenMap = map;\r\n        screenMap.grid = grid;\r\n        GenerateGrid(gridElement, screenMap.width, screenMap.height);\r\n    }\r\n    function GenerateGrid(el, rows, columns) {\r\n        while (el.lastChild) {\r\n            el.removeChild(el.lastChild);\r\n        }\r\n        const gridWidth = (el.clientWidth / rows);\r\n        const gridHeight = (el.clientHeight / columns);\r\n        for (let column = 0; column < columns; column++)\r\n            for (let row = 0; row < rows; row++)\r\n                el.appendChild(GenerateGridSpace(row, column, gridWidth, gridHeight));\r\n    }\r\n    function GenerateGridSpace(x, y, width, height) {\r\n        const element = document.createElement(\"div\");\r\n        element.style.width = width + \"px\";\r\n        element.style.height = height + \"px\";\r\n        element.style.marginLeft = width * x + \"px\";\r\n        element.style.marginTop = height * y + \"px\";\r\n        element.className = \"gridSpace open\";\r\n        element.setAttribute(\"x\", x.toString());\r\n        element.setAttribute(\"y\", y.toString());\r\n        element.appendChild(document.createElement(\"p\"));\r\n        element.appendChild(document.createElement(\"p\"));\r\n        element.appendChild(document.createElement(\"p\"));\r\n        element.appendChild(document.createElement(\"p\"));\r\n        for (let childIndex = 0; childIndex < element.children.length; childIndex++) {\r\n            const child = element.children.item(childIndex);\r\n            child.style.visibility = hideStats.checked ? \"hidden\" : \"visible\";\r\n        }\r\n        return element;\r\n    }\r\n    runButton.addEventListener(\"click\", () => {\r\n        if (screenMap !== undefined) {\r\n            ClearPath();\r\n            const heuristicStr = document.getElementById(\"heuristic\").value;\r\n            let heuristic = eval(heuristicStr);\r\n            //if (!(heuristic instanceof Function))\r\n            //    heuristic = Diagonal;\r\n            const neighborsStr = document.getElementById(\"neighbors\").value;\r\n            let neighbors = eval(neighborsStr);\r\n            //if (!(neighbors instanceof Array))\r\n            //    neighbors = [[-1, 1], [0, 1], [1, 1], [-1, 0], [1, 0], [-1, -1], [0, -1], [1, -1]];\r\n            screenMap.results = AStar_1.AStar(screenMap.start, screenMap.goal, screenMap.grid, heuristic, neighbors);\r\n            for (const space of screenMap.results.path) {\r\n                screenMap.grid[space.x][space.y] = 2;\r\n            }\r\n            UpdateGrid(gridElement);\r\n        }\r\n    });\r\n    function Diagonal(a, b) {\r\n        return Math.sqrt((b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y));\r\n    }\r\n    function ClearPath() {\r\n        const grid = screenMap;\r\n        for (let row = 0; row < screenMap.width; row++)\r\n            for (let column = 0; column < screenMap.height; column++)\r\n                if (grid.grid[row][column] === 2)\r\n                    grid.grid[row][column] = 0;\r\n    }\r\n    hideStats.addEventListener(\"click\", HideStats);\r\n    function HideStats() {\r\n        const gridSpaces = document.getElementsByClassName(\"gridSpace\");\r\n        for (let spaceIndex = 0; spaceIndex < gridSpaces.length; spaceIndex++) {\r\n            const space = gridSpaces.item(spaceIndex);\r\n            for (let childIndex = 0; childIndex < space.children.length; childIndex++) {\r\n                const child = space.children.item(childIndex);\r\n                child.style.visibility = this.checked ? \"hidden\" : \"visible\";\r\n            }\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=Page.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Page.js\n// module id = 0\n// module chunks = 0","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass GridPosition {\r\n    constructor(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    equals(a) {\r\n        return a.x === this.x && a.y === this.y;\r\n    }\r\n    toString() {\r\n        return \"(\" + this.x + \", \" + this.y + \")\";\r\n    }\r\n}\r\nexports.GridPosition = GridPosition;\r\nclass Node {\r\n    constructor(pos, g, parent) {\r\n        this.pos = pos;\r\n        this.g = g;\r\n        this.h = 0;\r\n        this.parent = parent;\r\n    }\r\n    get f() {\r\n        return this.g + this.h;\r\n    }\r\n    toString() {\r\n        return this.pos.toString() + \" g: \" + Math.round(this.g * 100) / 100 + \" h: \" + Math.round(this.h * 100) / 100 + \" f: \" + Math.round(this.f * 100) / 100;\r\n    }\r\n}\r\nexports.Node = Node;\r\nfunction smallestFIndex(list) {\r\n    let smallest = 0;\r\n    for (let index = 1; index < list.length; index++) {\r\n        if (list[smallest].f > list[index].f)\r\n            smallest = index;\r\n    }\r\n    return smallest;\r\n}\r\nfunction generateEdges(parent, grid, maxX, maxY, neighbors) {\r\n    const edges = [];\r\n    for (const dir of neighbors) {\r\n        const posx = parent.pos.x + dir[0];\r\n        const posy = parent.pos.y + dir[1];\r\n        if (posx >= 0 && posx < maxX && posy >= 0 && posy < maxY && grid[posx][posy] !== 1) {\r\n            edges.push(new Node(new GridPosition(posx, posy), parent.g, parent));\r\n        }\r\n    }\r\n    return edges;\r\n}\r\nfunction has(edge, list) {\r\n    for (const node of list) {\r\n        if (node.pos.equals(edge.pos))\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\nfunction constructPath(end) {\r\n    const path = [];\r\n    while (end !== undefined) {\r\n        path.push(end.pos);\r\n        end = end.parent;\r\n    }\r\n    return path;\r\n}\r\nfunction AStar(start, goal, grid, dist, neighbors) {\r\n    const historyGrid = [];\r\n    for (let row = 0; row < grid.length; row++) {\r\n        historyGrid.push([]);\r\n        for (let column = 0; column < grid[row].length; column++) {\r\n            historyGrid[row].push(new Node(new GridPosition(row, column), 0));\r\n        }\r\n    }\r\n    const open = [new Node(start, 0)];\r\n    const closed = [];\r\n    const maxX = grid.length;\r\n    const maxY = grid[0].length;\r\n    while (open.length > 0) {\r\n        const qIndex = smallestFIndex(open);\r\n        const q = open[qIndex];\r\n        open.splice(qIndex, 1);\r\n        const edges = generateEdges(q, grid, maxX, maxY, neighbors);\r\n        for (const edge of edges) {\r\n            if (edge.pos.equals(goal)) {\r\n                return {\r\n                    path: constructPath(edge),\r\n                    history: historyGrid\r\n                };\r\n            }\r\n            edge.g = dist(edge.pos, q.pos);\r\n            edge.h = dist(edge.pos, goal);\r\n            if (has(edge, closed))\r\n                continue;\r\n            if (has(edge, open)) {\r\n                const node = open.find((value) => {\r\n                    return value.pos.equals(edge.pos);\r\n                });\r\n                if (edge.f < node.f) {\r\n                    node.g = edge.g;\r\n                    node.h = edge.h;\r\n                    historyGrid[edge.pos.x][edge.pos.y].g = edge.g;\r\n                    historyGrid[edge.pos.x][edge.pos.y].h = edge.h;\r\n                }\r\n            }\r\n            else {\r\n                open.push(edge);\r\n                historyGrid[edge.pos.x][edge.pos.y].g = edge.g;\r\n                historyGrid[edge.pos.x][edge.pos.y].h = edge.h;\r\n            }\r\n        }\r\n        closed.push(q);\r\n    }\r\n    return {\r\n        path: [],\r\n        history: historyGrid\r\n    };\r\n}\r\nexports.AStar = AStar;\r\n//# sourceMappingURL=AStar.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AStar.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}